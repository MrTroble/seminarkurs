\section{Lambda calculus}
Der Lambda calculus ist ein Datenverarbeitungskonzept erfunden von Alonzo Church, dem Professor von Alan Turing. Turing studierte unter Church einige Zeit an der Princeton Universität bevor er dann wieder zurück nach England ging. Im folgenden Abschnitt wird kurz auf Church eingegangen, danach wird Churches Werk, der Lambda calculus, dessen Gesetze, Notation und Beispiele behandelt. Hier wird ein Einblick in die Welt der funktionellen Programmiersprachen und ihrer Geschichte gegeben.
\subsection{Alonzo Church}
Alonzo Church wurde am 14 Juni 1903 in Washington DC geboren. \cite{lifechurch}
\subsection{Gesetze des Lambda calculus}
Der Lambda calculus besteht aus 3 Grundgesetzen.
\begin{itemize}
\item Funktionen können definiert werden.
\item diese können/müssen Daten Ein und Ausgeben.
\item Funktionen können Angewendet werden
\end{itemize}
Ausführlicher: Es muss ein Weg vorhanden sein eine Funktion zu definieren, dafür gibt es eine Mathematische Definition. Die Erzeugung einer Funktion ist aber nicht auf die Mathematische Notation beschränkt, ganz im Gegenteil, die Notationen im Modernen Lambda Programming weichen, nicht zuletzt aus technischen Gründen, stark von der Mathematischen Notation ab. Dabei müssen im originalen Lambda Ein- und Ausgaben definiert werden. Dies weicht im modernen Lambda ebenfalls von der originalen Definition ab. Hier können Ein- und Ausgaben definiert werden, müssen es aber nicht. Dies führt zu mehr Flexibilität, so können die Lambda Funktionen auch an stellen Eingesetzt werden wo nicht direkt Daten verarbeitet werden. Als letztes kennt man beim Ausführen der Funktion den Inhalt der Funktion nicht. Das ist der große unterschied zu anderen Mathematischen Funktionen.\cite{lambdacalculus}

\subsection{Mathematische Notation}
Für den Ursprünglichen Lambda calculus definiert von Alonzo Church gibt es auch 
eine Mathematische Notation die wie Folgt durch das Zeichen Lambda eingeleitet wird.
\begin{equation}
\lambda x. x + 1
\end{equation}
Diese Funktion beschreit eine Inkrement Funktion. Dabei ist es wichtig anzumerken das wir nicht wissen was die Funktion wirklich tut. Wir können nur sagen was in die Funktion herein gegeben wird und was am ende von der Funktion heraus kommt. Wobei die Inputs mit dem $\lambda$ (lambda) Symbol Gekennzeichnet sind und mit einem Punkt enden. Am Schluss Folgt der Output. Um es nochmal zu betonen wir wissen nicht was die Funktion im inneren tut. Sie (die Funktion) könnte beim ausführen $x + 2 - 1$ rechnen oder $x + 4 - 3$ das kann man in diesem Model nicht beschreiben, klar ist nur es kommt immer $x + 1$ heraus.
Die Ursprüngliche Notation ist weit aus Mathematischer als die in derzeitigen Programmiersprachen. Dennoch lassen sich damit beliebig Daten durch das sog. Kodieren wie im Folgenden Beispiel verarbeiten.
Gegeben sind zwei Funktionen.
\begin{equation}
TRUE = \lambda x. \lambda y. x
\end{equation}
\begin{equation}
FALSE = \lambda x. \lambda y. y
\end{equation}
Diese zwei Funktionen sollen nun zu einem Logischen Und-Gatter zusammen gefügt werden.
Dabei entsteht folgende Funktion.
\begin{equation}
AND = \lambda x. \lambda y. x y x
\end{equation}
Nun wird auf die und Funktion als Beispiel die Funktionen TRUE und FALSE angewendet. Dazu werden einfach die variablen mit den als Eingabe verwendeten Funktionen ausgetauscht. In diesem konkreten Beispiel wird TRUE und TRUE auf die Funktion AND angewendet
\begin{equation}
\text{AND TRUE TRUE} = (\lambda x. \lambda y. x y x) \text{ TRUE TRUE} 
\end{equation}
Hier wird detailliert aufgeschrieben wie man die Funktionen auflöst. Man nimmt immer die Funktion die am weitesten links steht und schreibt auf wie sie aufgebaut ist. Die Nachfolgenden Methoden bzw. Daten werden nun als input verwendet. In diesem Fall natürlich die kodierten Funktionen. In diesem Fall ist die Funktion AND definiert als $x y x$
und gegeben sind die Inputs $x = TRUE$ und $y = TRUE$ dies wird nun wieder hingeschrieben und es wird weiter aufgelöst. 
\begin{equation}
\text{ TRUE TRUE TRUE} = (\lambda x. \lambda y. x) \text{ TRUE TRUE} = \text{TRUE}
\end{equation}
Nun wird auf die ganz links stehende Funktion TRUE die Inputs $x = TRUE$ und $y = TRUE$ angewendet da sich TRUE immer zum x auflöst ist das Ergebniss als AND TRUE TRUE = TRUE
Und dies bestätigt die Annahme. Um ein gegen Beispiel zu bringen wird im nächsten Beispiel FALSE und TRUE übergeben.
\begin{equation}
\text{AND FALSE TRUE = FALSE TRUE FALSE = FALSE}
\end{equation}
Und auch hier funktioniert die Und-Funktion wie gedacht. So kann man alle Möglichen Arten von Daten Transformation in Lambda Funktionen darstellen. 
\cite{lambdacalculus}

\subsection{Lambda in Programmiersprachen}
Schauen wir uns nun zur weiteren Erläuterung ein Beispiel aus Java an. Diese Beispiele sind weitaus Moderner und weichen in Teilen von der Originalen Definition ab beziehungsweise fügen neue Regeln hinzu. Es gibt eine Funktionsdeklaration die der Implementation vorgibt welche Ein und Ausgänge eine gewisse Lambda Funktion hat sowie ihren Namen.
\begin{minted}{java}
@FunctionalInterface
public interface TestFunctionalInterface {
	public int test(double d);
}
\end{minted}
Die Funktion wird nun als Interface übergeben und von einer ausführenden Funktion genutzt.
Was hier auffällt ist das die ausführende Funktion nicht weiß was die Funktion eigentlich tut.
\begin{minted}{java}
public void runTest(TestFunctionalInterface interf) {
	int testres = interf.test(89.1);
	// Mache etwas mit dem resultat
}
\end{minted}
Normalerweise müsste man dieses Interface überschreiben und dort dann implementieren was die Funktion tun würde. Hier gibt es allerdings eine separate schreib weise um eine Funktion zu definieren. Die wie folgt durch die Zeichen Kombination $->$ eingeleitet wird. Rechts von dem sog. Lambda operator stehen die Inputs rechts die Operationen bzw. Outputs. Im folgenden wird die gerade erzeugte Funktion auf \emph{runTest} angewendet.
\begin{minted}{java}
public void main() {
	runTest(input -> (int)(input + 1));
}
\end{minted}
Und nicht nur Java hat diese Art Paradigma übernommen, auch C++ zum Beispiel hat (zusätzlich zu den bereits vorhandenen Funktions Pointern) Lambda Funktionen eingeführt.
In C++ haben die Lambda Funktionen eine leicht veränderte Anwendungsstruktur.
\begin{minted}{c++}
playercontroller = [](Input* input) { 
topdown.positiony += input->y1; 
topdown.positionx -= input->x1;
setTopDownCamera(&topdown); 
};
\end{minted}
Hier wird eine Player Controller Funktion in meiner Engine definiert. Der Player Controller bekommt die letzten Inputs des Players in die Funktion und verarbeitet diese dann weiter.

\footnote{Kapitel 4 von Nico}