\section{Lambda calculus}
Der Lambda calculus ist ein Datenverarbeitungskonzept erfunden von Alonzo Church, dem Professor von Alan Turing. Turing studierte unter Church einige Zeit an der Princeton Universität bevor er dann wieder zurück nach England ging. Im folgenden Abschnitt wird kurz auf Church eingegangen, danach wird Churches Werk, der Lambda calculus, dessen Gesetze, Notation und Beispiele behandelt. Hier wird ein Einblick in die Welt der funktionellen Programmiersprachen und ihrer Geschichte gegeben.
\subsection{Alonzo Church}
\subsection{Gesetze des Lambda calculus}
Der Lambda calculus besteht aus 3 Grundgesetzen.
\begin{itemize}
\item Funktionen können definiert werden.
\item diese können/müssen Daten Ein und Ausgeben.
\item Funktionen können Angewendet werden
\end{itemize}
Ausführlicher: Es muss ein Weg vorhanden sein eine Funktion zu definieren, dafür gibt es eine Mathematische Definition. Die Erzeugung einer Funktion ist aber nicht auf die Mathematische Notation beschränkt, ganz im Gegenteil, die Notationen im Modernen Lambda Programming weichen, nicht zuletzt aus technischen Gründen, stark von der Mathematischen Notation ab. Dabei müssen im originalen Lambda Ein- und Ausgaben definiert werden. Dies weicht im modernen Lambda ebenfalls von der originalen Definition ab. Hier können Ein- und Ausgaben definiert werden, müssen es aber nicht. Dies führt zu mehr Flexibilität, so können die Lambda Funktionen auch an stellen Eingesetzt werden wo nicht direkt Daten verarbeitet werden. Als letztes kennt man beim Ausführen der Funktion den Inhalt der Funktion nicht. Das ist der große unterschied zu anderen Mathematischen Funktionen.\cite{lambdacalculus}
\subsection{Lambda in Programmiersprachen}
Schauen wir uns zur Erläuterung ein Beispiel aus Java an.
Es gibt eine Funktionsdeklaration die der Implementation vorgibt welche Ein und Ausgänge
eine gewisse Lambda Funktion hat sowie ihren Namen.
\begin{minted}{java}
@FunctionalInterface
public interface TestFunctionalInterface {
	public int test(double d);
}
\end{minted}
Die Funktion wird nun als Interface übergeben und von einer ausführenden Funktion genutzt.
Was hier auffällt ist das die ausführende Funktion nicht weiß was die Funktion eigentlich tut.
\begin{minted}{java}
public void runTest(TestFunctionalInterface interf) {
	int testres = interf.test(89.1);
	// Mache etwas mit dem resultat
}
\end{minted}
Normalerweise müsste man dieses Interface überschreiben und dort dann implementieren was die Funktion tun würde. Hier gibt es allerdings eine separate schreib weise um eine Funktion zu definieren. Die wie folgt durch die Zeichen Kombination -> eingeleitet wird.
Rechts von dem sog. Lambda operator stehen die Inputs rechts die Operationen bzw. Outputs 
Im folgenden wird die gerade erzeugte
\begin{minted}{java}
public void main() {
	runTest(input -> (int)Math.ceil(input));
}
\end{minted}

\subsection{Mathematische Notation}
Für den Ursprünglichen Lambda calculus definiert von Alonzo Church gibt es auch 
eine Mathematische Notation die wie Folgt durch das Zeichen Lambda eingeleitet wird.
\begin{equation}
\lambda x. x + 1
\end{equation}
Diese Funktion beschreit eine Inkrement Funktion. Dabei ist es wichtig anzumerken das wir nicht wissen was die Funktion wirklich tut. Wir können nur sagen was in die Funktion herein gegeben wird und was am ende von der Funktion heraus kommt. Wobei die Inputs mit dem $\lambda$ (lambda) Symbol Gekennzeichnet sind und mit einem Punkt enden. Am Schluss Folgt der Output. Um es nochmal zu betonen wir wissen nicht was die Funktion im inneren tut. Sie (die Funktion) könnte beim ausführen $x + 2 - 1$ rechnen oder $x + 4 - 3$ das kann man in diesem Model nicht beschreiben, klar ist nur es kommt immer $x + 1$ heraus.
Die Ursprüngliche Notation ist weit aus Mathematischer als die in derzeitigen Programmiersprachen. Dennoch lassen sich damit beliebig Daten durch das sog. Kodieren wie im Folgenden Beispiel verarbeiten.
Gegeben sind zwei Funktionen.
\begin{equation}
TRUE = \lambda x. \lambda y. x
\end{equation}
\begin{equation}
FALSE = \lambda x. \lambda y. y
\end{equation}
Diese zwei Funktionen sollen nun zu einem Logischen Und-Gatter zusammen gefügt werden.
Dabei entsteht folgende Funktion.
\begin{equation}
AND = \lambda x. \lambda y. x y x
\end{equation}
Nun wird auf die und Funktion als Beispiel die Funktionen TRUE und FALSE angewendet. Dazu werden einfach die variablen mit den als Eingabe verwendeten Funktionen ausgetauscht.
\begin{equation}
\text{AND TRUE TRUE} = (\lambda x. \lambda y. x y x) \text{ TRUE TRUE} 
\end{equation}
\begin{equation}
\text{ TRUE TRUE TRUE} = (\lambda x. \lambda y. x) \text{ TRUE TRUE} = \text{TRUE}
\end{equation}
\footnote{Kapitel 4 von Nico}\cite{lambdacalculus} 