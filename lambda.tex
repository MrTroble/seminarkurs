\section{Lambda calculus}
Der Lambda calculus ist ein Datenverarbeitungskonzept erfunden von Alonzo Church, dem Professor von Alan Turing. Turing studierte unter Church einige Zeit an der Princeton Universität bevor er dann wieder zurück nach England ging. Im folgenden Abschnitt wird kurz auf Church eingegangen, danach wird Churches Werk, der Lambda calculus, dessen Gesetze, Notation und Beispiele behandelt. Hier wird ein Einblick in die Welt der funktionellen Programmiersprachen und ihrer Geschichte gegeben.
\subsection{Alonzo Church}
\subsection{Gesetze des Lambda calculus}
Der Lambda calculus besteht aus 3 Grundgesetzen.
\begin{itemize}
\item Funktionen können erstellt werden.
\item diese können/müssen Daten Ein und Ausgeben.
\item Man weiß nicht was die Funktionen tun.
\end{itemize}
Ausführlicher: Es muss ein Weg vorhanden sein eine Funktion zu definieren, dafür gibt es eine Mathematische Definition. Die Erzeugung einer Funktion ist aber nicht auf die Mathematische Notation beschränkt, ganz im Gegenteil, die Notationen im Modernen Lambda Programming weichen, nicht zuletzt aus technischen Gründen, stark von der Mathematischen Notation ab. Dabei müssen im originalen Lambda Ein- und Ausgaben definiert werden. Dies weicht im modernen Lambda ebenfalls von der originalen Definition ab. Hier können Ein- und Ausgaben definiert werden, müssen es aber nicht. Dies führt zu mehr Flexibilität, so können die Lambda Funktionen auch an stellen Eingesetzt werden wo nicht direkt Daten verarbeitet werden. Als letztes kennt man beim Ausführen der Funktion den Inhalt der Funktion nicht. Das ist der große unterschied zu anderen Mathematischen Funktionen.\cite{lambdacalculus}
\subsection{Lambda in Programmiersprachen}
Schauen wir uns zur Erläuterung ein Beispiel aus Java an.
Es gibt eine Funktionsdeklaration die der Implementation vorgibt welche Ein und Ausgänge
eine gewisse Lambda Funktion hat sowie ihren Namen.
\begin{minted}{java}
@FunctionalInterface
public interface TestFunctionalInterface {
	public int test(double d);
}
\end{minted}
Die Funktion wird nun als Interface übergeben und von einer ausführenden Funktion genutzt.
Was hier auffällt ist das die ausführende Funktion nicht weiß was die Funktion eigentlich tut.
\begin{minted}{java}
public void runTest(TestFunctionalInterface interf) {
	int testres = interf.test(89.1);
	// Mache etwas mit dem resultat
}
\end{minted}
Normalerweise müsste man dieses Interface überschreiben und dort dann implementieren was die Funktion tun würde. Hier gibt es allerdings eine separate schreib weise um eine Funktion zu definieren. Die wie folgt durch die Zeichen Kombination -> eingeleitet wird.
Rechts von dem sog. Lambda operator stehen die Inputs rechts die Operationen bzw. Outputs 
\begin{minted}{java}
public void main() {
	runTest(input -> (int)Math.ceil(input));
}
\end{minted}

\subsection{Mathematische Notation}
Für den Ursprünglichen Lambda calculus definiert von Alonzo Church gibt es auch eine Mathematische Notation die wie Folgt durch das Zeichen Lambda eingeleitet wird.
\begin{equation}
\lambda(x) = x * 2
\end{equation}
Die Ursprüngliche Notation ist weit aus Mathematischer als die in derzeitigen Programmiersprachen. Dennoch lassen sich damit beliebig Daten verarbeiten. .\cite{lambdacalculus}
\begin{equation}
\lambda
\end{equation}
So lässt sich z.B. ein boolean wert (also true/false oder 1/0) verarbeiten 
\footnote{Kapitel 4 von Nico}